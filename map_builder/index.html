<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Advanced Tile Map Builder</title>

  <!-- Tailwind CDN (for quick prototype) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* small helper so canvases stay crisp with pixel art */
    canvas { image-rendering: pixelated; }
  </style>
</head>
<body class="min-h-screen bg-gray-900 text-slate-100 font-sans">
  <div class="p-4 h-screen box-border flex gap-4">
    <!-- LEFT PANEL -->
    <aside class="w-80 bg-slate-800 rounded-xl p-4 flex-shrink-0 shadow-lg overflow-auto">
      <h2 class="text-white text-sm font-semibold mb-2">Tileset</h2>

      <label id="uploadTilesetBtn" class="block mb-2">
        <input id="tilesetInput" type="file" accept="image/*" class="hidden">
        <button type="button" class="w-full bg-slate-700 hover:bg-slate-600 text-slate-100 py-2 rounded-md flex items-center justify-center gap-2">
          <!-- heroicon: upload -->
          <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M3 8a1 1 0 011-1h3V4a1 1 0 112 0v3h3a1 1 0 011 1v7a1 1 0 01-1 1H4a1 1 0 01-1-1V8z" clip-rule="evenodd"/></svg>
          Upload Tileset (e.g. 16Ã—16)
        </button>
      </label>

      <div class="bg-slate-900 rounded-md p-2 border border-slate-700">
        <canvas id="tilesetCanvas" class="w-full block border border-slate-700 rounded-sm"></canvas>
      </div>

      <div class="mt-3 grid grid-cols-2 gap-3">
        <div>
          <label class="text-xs text-slate-400">Tile Size</label>
          <input id="tileSizeInput" type="number" value="16" min="4" max="128" class="w-full mt-1 bg-slate-800 rounded px-2 py-1 text-sm">
        </div>
        <div>
          <label class="text-xs text-slate-400">Brush</label>
          <select id="brushSize" class="w-full mt-1 bg-slate-800 rounded px-2 py-1 text-sm">
            <option value="1">1Ã—1</option>
            <option value="2">2Ã—2</option>
            <option value="3">3Ã—3</option>
          </select>
        </div>
      </div>

      <h2 class="text-white text-sm font-semibold mt-4 mb-2">Layers</h2>
      <div class="flex gap-2 mb-2">
        <button id="addLayer" class="flex-1 bg-emerald-600 hover:bg-emerald-500 py-1 rounded text-sm">+ Add</button>
        <button id="removeLayer" class="flex-1 bg-red-600 hover:bg-red-500 py-1 rounded text-sm">Remove</button>
      </div>
      <div class="flex gap-2 mb-3">
        <button id="layerUp" class="w-1/2 bg-slate-700 py-1 rounded text-sm">â–²</button>
        <button id="layerDown" class="w-1/2 bg-slate-700 py-1 rounded text-sm">â–¼</button>
      </div>

      <div id="layersList" class="space-y-2 max-h-48 overflow-auto"></div>

      <div class="mt-3">
        <label class="text-xs text-slate-400">Map Size</label>
        <div class="mt-1 flex gap-2 items-center">
          <input id="mapWidth" type="number" value="30" class="w-20 bg-slate-800 rounded px-2 py-1 text-sm">
          <input id="mapHeight" type="number" value="20" class="w-20 bg-slate-800 rounded px-2 py-1 text-sm">
          <button id="createMap" class="ml-auto bg-indigo-600 hover:bg-indigo-500 px-3 py-1 rounded text-sm">Create</button>
        </div>
      </div>

      <h2 class="text-white text-sm font-semibold mt-4 mb-2">File</h2>
      <div class="flex gap-2">
        <button id="downloadJson" class="flex-1 bg-slate-700 hover:bg-slate-600 py-2 rounded text-sm">Download JSON</button>
        <label id="loadJsonLabel" class="w-1/3">
          <input id="loadJsonInput" type="file" accept=".json" class="hidden">
          <button class="w-full bg-slate-700 hover:bg-slate-600 py-2 rounded text-sm">Load</button>
        </label>
      </div>

      <div class="mt-3 text-xs text-slate-400 space-y-1">
        <div>Pan: middle-mouse drag OR hold <kbd class="bg-slate-800 px-1 rounded">Space</kbd> + left-drag</div>
        <div>Zoom: mouse wheel</div>
        <div>Erase: right-click</div>
        <div>Drag paint: left-button drag</div>
      </div>

      <div class="mt-4 text-xs text-slate-500">Advanced Tile Map Builder â€” dynamic layers, zoom, pan, save/load</div>
    </aside>

    <!-- RIGHT / CANVAS -->
    <main class="flex-1 flex flex-col gap-3">
      <div class="flex items-center gap-3">
        <div class="flex gap-2" id="toolbar">
          <button id="toggleGrid" class="bg-slate-700 hover:bg-slate-600 px-3 py-1 rounded text-sm flex items-center gap-2">
            <!-- grid icon -->
            <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor"><path d="M3 3h4v4H3V3zm6 0h4v4H9V3zM3 9h4v4H3V9zm6 0h4v4H9V9zM3 15h4v2H3v-2zm6 0h4v2H9v-2z"/></svg> Grid
          </button>
          <button id="toggleLayerPreview" class="bg-slate-700 hover:bg-slate-600 px-3 py-1 rounded text-sm flex items-center gap-2">
            Preview
          </button>
          <button id="clearLayer" class="bg-yellow-600 hover:bg-yellow-500 px-3 py-1 rounded text-sm">Clear Layer</button>
          <button id="spawnTool" class="bg-slate-700 hover:bg-slate-600 px-3 py-1 rounded text-sm flex items-center gap-2">
            <!-- spawn icon (simple target) -->
            <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0-2a6 6 0 100-12 6 6 0 000 12zm0-2a4 4 0 100-8 4 4 0 000 8z" clip-rule="evenodd"/></svg> Spawn
          </button>
        </div>

        <div class="ml-auto text-sm text-slate-400" id="status">Selected tile: - | Layer: - | Scale: 100%</div>
      </div>

      <div id="mapContainer" class="flex-1 bg-slate-900 rounded-xl p-3 overflow-hidden">
        <div id="canvasWrap" class="bg-black rounded w-full h-full relative flex items-center justify-center">
          <canvas id="mapCanvas" width="800" height="600" class="absolute inset-0"></canvas>
          <canvas id="preview" width="800" height="600" class="absolute inset-0 pointer-events-none"></canvas>
        </div>
      </div>

      <div class="flex items-center gap-3">
        <div class="text-xs text-slate-400">Tileset:</div>
        <div id="tilesetInfo" class="text-xs text-slate-300">No tileset loaded</div>
      </div>
    </main>
  </div>

<script>
/* ==========================
   Advanced Tile Map Builder
   Tailwind + memory fixes
   + Spawn Point Feature
   ========================== */

const tilesetInput = document.getElementById('tilesetInput');
const uploadTilesetBtn = document.getElementById('uploadTilesetBtn');
const tilesetCanvas = document.getElementById('tilesetCanvas');
const tilesetCtx = tilesetCanvas.getContext('2d');

const tileSizeInput = document.getElementById('tileSizeInput');
let tileSize = parseInt(tileSizeInput.value, 10);

const tilesAcrossHeight = { across:0, rows:0 };
let tilesetImage = null;
let selectedTile = -1;
let currentTilesetObjectURL = null;

uploadTilesetBtn.addEventListener('click', ()=> tilesetInput.click());
tilesetInput.addEventListener('change', handleTilesetUpload);
tileSizeInput.addEventListener('change', e=>{
  tileSize = Math.max(4, parseInt(e.target.value)||16);
  redrawTileset();
  // cell coords depend on tile size -> re-create map tile world x/y
  rebuildTileWorldCoords();
});

const mapCanvas = document.getElementById('mapCanvas');
const mapCtx = mapCanvas.getContext('2d');
const previewCanvas = document.getElementById('preview');
const previewCtx = previewCanvas.getContext('2d');

let mapWidth = parseInt(document.getElementById('mapWidth').value,10);
let mapHeight = parseInt(document.getElementById('mapHeight').value,10);

// normalized layers: { name, visible, tiles: [ [ {tx,ty}, ... ], ... ] }
let layers = [];
let activeLayer = 0;

const layersList = document.getElementById('layersList');
document.getElementById('addLayer').addEventListener('click', addLayer);
document.getElementById('removeLayer').addEventListener('click', removeLayer);
document.getElementById('layerUp').addEventListener('click', ()=> moveLayer(-1));
document.getElementById('layerDown').addEventListener('click', ()=> moveLayer(1));
document.getElementById('createMap').addEventListener('click', ()=> {
  mapWidth = parseInt(document.getElementById('mapWidth').value,10) || mapWidth;
  mapHeight = parseInt(document.getElementById('mapHeight').value,10) || mapHeight;
  createMap(mapWidth, mapHeight);
});

document.getElementById('downloadJson').addEventListener('click', downloadJSON);
document.getElementById('loadJsonLabel').addEventListener('click', ()=> document.getElementById('loadJsonInput').click());
document.getElementById('loadJsonInput').addEventListener('change', loadJSONFromFile);

document.getElementById('brushSize').addEventListener('change', ()=> {});
document.getElementById('toggleGrid').addEventListener('click', ()=> { showGrid = !showGrid; draw(); });
document.getElementById('toggleLayerPreview').addEventListener('click', ()=> { layerPreview = !layerPreview; draw(); });
document.getElementById('clearLayer').addEventListener('click', ()=> { if(confirm('Clear active layer?')) clearActiveLayer(); });

const statusEl = document.getElementById('status');
const tilesetInfo = document.getElementById('tilesetInfo');

let showGrid = true;
let layerPreview = true;

// New: Spawn point feature
let spawnPoint = { x: -1, y: -1 };
let spawnMode = false;
const spawnTool = document.getElementById('spawnTool');
spawnTool.addEventListener('click', () => {
  spawnMode = !spawnMode;
  spawnTool.classList.toggle('bg-indigo-600', spawnMode);
  spawnTool.classList.toggle('bg-slate-700', !spawnMode);
  mapCanvas.style.cursor = spawnMode ? 'pointer' : (spaceDown ? 'grab' : 'crosshair');
});

/* ---------- Map transform (zoom/pan) ---------- */
let scale = 1.0;
let offsetX = 0;
let offsetY = 0;
let isPanning = false;
let panStart = {x:0,y:0, ox:0, oy:0};
let spaceDown = false;
window.addEventListener('keydown', e=> { if(e.code==='Space') { spaceDown = true; mapCanvas.style.cursor = spawnMode ? 'pointer' : 'grab'; } });
window.addEventListener('keyup', e=> { if(e.code==='Space') { spaceDown = false; mapCanvas.style.cursor = spawnMode ? 'pointer' : 'crosshair'; } });

// wheel zoom (preserve world point under cursor)
mapCanvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const rect = mapCanvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const wheel = e.deltaY < 0 ? 1.12 : 0.88;
  const worldX = (mouseX - offsetX) / scale;
  const worldY = (mouseY - offsetY) / scale;
  scale = Math.min(8, Math.max(0.2, scale * wheel));
  offsetX = mouseX - worldX * scale;
  offsetY = mouseY - worldY * scale;
  updateStatus();
  draw();
}, {passive:false});

/* ---------- Painting state ---------- */
let isPainting = false;
let isErasing = false;

mapCanvas.addEventListener('mousedown', e=>{
  // left = paint, middle = pan, right = erase
  if(e.button === 1 || (e.button === 0 && spaceDown)) {
    isPanning = true;
    panStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY };
    mapCanvas.style.cursor = 'grabbing';
    return;
  }

  if(spawnMode) {
    if(e.button === 0) {
      setSpawnAtEvent(e);
      return;
    } else if(e.button === 2) {
      e.preventDefault();
      spawnPoint = { x: -1, y: -1 };
      draw();
      updateStatus();
      return;
    }
  }

  if(e.button === 2) {
    e.preventDefault();
    isErasing = true;
    paintAtEvent(e, true);
    return;
  }

  if(e.button === 0) {
    isPainting = true;
    paintAtEvent(e, false);
  }
});

window.addEventListener('mouseup', e=>{
  if(isPanning) { isPanning = false; mapCanvas.style.cursor = spaceDown ? 'grab' : 'crosshair'; }
  isPainting = false;
  isErasing = false;
});

mapCanvas.addEventListener('mousemove', e=>{
  if(isPanning) {
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    offsetX = panStart.ox + dx;
    offsetY = panStart.oy + dy;
    draw();
    updateStatus();
    return;
  }

  if(isPainting) paintAtEvent(e, false);
  if(isErasing) paintAtEvent(e, true);

  drawPreviewAt(e);
});

mapCanvas.addEventListener('contextmenu', e => { e.preventDefault(); });
mapCanvas.addEventListener('mouseleave', ()=> { drawPreviewClear(); });

/* ---------- Tileset interaction ---------- */
tilesetCanvas.addEventListener('click', e=>{
  if(!tilesetImage) return;
  const tx = Math.floor(e.offsetX / tileSize);
  const ty = Math.floor(e.offsetY / tileSize);
  const across = Math.max(1, Math.floor(tilesetImage.width / tileSize));
  selectedTile = ty * across + tx;
  drawTileset();
  updateStatus();
});

/* redraw tileset with highlight */
function redrawTileset(){
  if(!tilesetImage) {
    tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
    tilesetInfo.textContent = 'No tileset loaded';
    return;
  }
  tilesetCanvas.width = tilesetImage.width;
  tilesetCanvas.height = tilesetImage.height;
  tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
  tilesetCtx.drawImage(tilesetImage, 0,0);
  drawTileset();
}

/* draw tileset highlight */
function drawTileset(){
  if(!tilesetImage) {
    tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
    tilesetInfo.textContent = 'No tileset loaded';
    return;
  }
  tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
  tilesetCtx.drawImage(tilesetImage,0,0);
  const across = Math.max(1, Math.floor(tilesetImage.width / tileSize));
  tilesAcrossHeight.across = across;
  tilesAcrossHeight.rows = Math.ceil(tilesetImage.height / tileSize);
  tilesetInfo.textContent = `${tilesetImage.width}Ã—${tilesetImage.height} â€” ${across} across Ã— ${tilesAcrossHeight.rows} rows`;

  if(selectedTile >= 0) {
    const sx = (selectedTile % across) * tileSize;
    const sy = Math.floor(selectedTile / across) * tileSize;
    tilesetCtx.lineWidth = 2;
    tilesetCtx.strokeStyle = 'yellow';
    tilesetCtx.strokeRect(sx+1, sy+1, tileSize-2, tileSize-2);
  }
}

/* handle file upload - revoke previous object URLs to prevent leaks */
function handleTilesetUpload(e){
  const file = e.target.files[0];
  if(!file) return;

  // revoke previous object URL if any
  if(currentTilesetObjectURL) {
    try { URL.revokeObjectURL(currentTilesetObjectURL); } catch(_) {}
    currentTilesetObjectURL = null;
  }

  const img = new Image();
  const url = URL.createObjectURL(file);
  currentTilesetObjectURL = url;
  img.onload = () => {
    // once the image data is loaded into memory, we can revoke the blob URL
    try { URL.revokeObjectURL(url); } catch(_) {}
    currentTilesetObjectURL = null;

    // detach any previous image reference so it can GC
    if(tilesetImage && tilesetImage.__onload) {
      tilesetImage.__onload = null;
    }
    tilesetImage = img;
    tilesetImage.__onload = true; // small marker

    tileSize = Math.max(4, parseInt(tileSizeInput.value,10) || 16);
    tilesetCanvas.width = img.width;
    tilesetCanvas.height = img.height;
    drawTileset();
    draw();
  };
  img.onerror = () => {
    alert('Failed to load image');
    try { URL.revokeObjectURL(url); } catch(_) {}
    currentTilesetObjectURL = null;
  };
  img.src = url;
}

/* ---------- Map Data / Layers ---------- */
function createEmptyLayer(name){
  const arr = [];
  for(let y=0;y<mapHeight;y++){
    const row = [];
    for(let x=0;x<mapWidth;x++){
      row.push({ tx: -1, ty: -1 });
    }
    arr.push(row);
  }
  return { name: name||`Layer ${layers.length}`, visible:true, tiles: arr };
}

function createMap(w,h){
  mapWidth = w; mapHeight = h;
  if(layers.length === 0) {
    layers.push(createEmptyLayer('Ground'));
    activeLayer = 0;
  } else {
    for(const L of layers){
      const newTiles = [];
      for(let y=0;y<mapHeight;y++){
        const row = [];
        for(let x=0;x<mapWidth;x++){
          if(L.tiles[y] && L.tiles[y][x]) {
            const c = L.tiles[y][x];
            row.push({ tx: (c.tx ?? -1), ty: (c.ty ?? -1) });
          } else {
            row.push({ tx: -1, ty: -1 });
          }
        }
        newTiles.push(row);
      }
      L.tiles = newTiles;
    }
  }
  // Reset spawn if out of bounds
  if (spawnPoint.x >= mapWidth || spawnPoint.y >= mapHeight) {
    spawnPoint = { x: -1, y: -1 };
  }
  resizeCanvases();
  refreshLayersUI();
  draw();
}

function rebuildTileWorldCoords() {
  // kept for backwards compatibility with earlier code paths that stored x/y; here we don't store world x/y
}

/* Layer management */
function addLayer(){
  const name = prompt('Layer name', `Layer ${layers.length}`);
  layers.splice(activeLayer+1, 0, createEmptyLayer(name));
  activeLayer = activeLayer+1;
  refreshLayersUI();
  draw();
}

function removeLayer(){
  if(layers.length === 0) return;
  if(!confirm('Remove active layer?')) return;
  layers.splice(activeLayer,1);
  activeLayer = Math.max(0, activeLayer-1);
  refreshLayersUI();
  draw();
}

function moveLayer(dir){
  const idx = activeLayer;
  const to = idx + dir;
  if(to < 0 || to >= layers.length) return;
  const tmp = layers[to];
  layers[to] = layers[idx];
  layers[idx] = tmp;
  activeLayer = to;
  refreshLayersUI();
  draw();
}

function refreshLayersUI(){
  // clear and re-create items
  layersList.innerHTML = '';
  for(let i=layers.length-1;i>=0;i--){ // show top first
    const L = layers[i];
    const item = document.createElement('div');
    item.className = 'flex items-center gap-2 p-2 rounded bg-slate-800';
    item.dataset.idx = i;

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = !!L.visible;
    cb.title = 'visible';
    cb.addEventListener('change', ()=> {
      L.visible = cb.checked;
      draw();
    });

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.value = L.name;
    nameInput.className = 'bg-transparent border-0 text-sm text-slate-100 w-full';
    nameInput.addEventListener('change', ()=> { L.name = nameInput.value; });

    const eyeBtn = document.createElement('button');
    eyeBtn.className = 'ml-2 text-sm';
    eyeBtn.title = 'Select layer';
    eyeBtn.innerHTML = 'ðŸ‘ï¸';
    eyeBtn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      L.visible = !L.visible;
      cb.checked = L.visible;
      draw();
    });

    item.appendChild(cb);
    item.appendChild(nameInput);
    item.appendChild(eyeBtn);

    if(i === activeLayer) {
      item.classList.add('ring', 'ring-amber-400', 'ring-opacity-20');
    }

    item.addEventListener('click', ()=> {
      activeLayer = i;
      refreshLayersUI();
      updateStatus();
      draw();
    });

    layersList.appendChild(item);
  }
  updateStatus();
}

/* ---------- Painting functions ---------- */
function paintAtEvent(e, erase){
  if(!layers[activeLayer]) return;
  const rect = mapCanvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const worldX = (sx - offsetX) / scale;
  const worldY = (sy - offsetY) / scale;
  const tx = Math.floor(worldX / tileSize);
  const ty = Math.floor(worldY / tileSize);

  let tileCoord = null;
  if(!erase && selectedTile >= 0 && tilesetImage) {
    const across = Math.max(1, Math.floor(tilesetImage.width / tileSize));
    tileCoord = { tx: selectedTile % across, ty: Math.floor(selectedTile / across) };
  }

  applyBrushAt(tx, ty, erase ? null : tileCoord);
  draw();
}

function applyBrushAt(tileX, tileY, tileCoord){
  if(!layers[activeLayer]) return;
  const brush = parseInt(document.getElementById('brushSize').value,10) || 1;
  const half = Math.floor((brush-1)/2);
  for(let by=0; by<brush; by++){
    for(let bx=0; bx<brush; bx++){
      const x = tileX + bx - half;
      const y = tileY + by - half;
      if(x < 0 || y < 0 || x >= mapWidth || y >= mapHeight) continue;
      if(tileCoord) {
        layers[activeLayer].tiles[y][x] = { tx: tileCoord.tx, ty: tileCoord.ty };
      } else {
        layers[activeLayer].tiles[y][x] = { tx:-1, ty:-1 };
      }
    }
  }
}

// New: Set spawn point at mouse event
function setSpawnAtEvent(e) {
  const rect = mapCanvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const worldX = (sx - offsetX) / scale;
  const worldY = (sy - offsetY) / scale;
  const tx = Math.floor(worldX / tileSize);
  const ty = Math.floor(worldY / tileSize);
  if (tx >= 0 && ty >= 0 && tx < mapWidth && ty < mapHeight) {
    spawnPoint = { x: tx, y: ty };
    draw();
    updateStatus();
  }
}

/* ---------- Draw map ---------- */
function resizeCanvases(){
  const wrap = document.getElementById('canvasWrap');
  // make map canvas match container pixel size for crisp rendering
  mapCanvas.width = Math.max(200, Math.floor(wrap.clientWidth));
  mapCanvas.height = Math.max(200, Math.floor(wrap.clientHeight));
  previewCanvas.width = mapCanvas.width;
  previewCanvas.height = mapCanvas.height;
}
window.addEventListener('resize', ()=> { resizeCanvases(); draw(); });

let globalResizeObserver = null;
(function attachObserverOnce(){
  const wrap = document.getElementById('canvasWrap');
  if(!globalResizeObserver) {
    globalResizeObserver = new ResizeObserver(() => { resizeCanvases(); draw(); });
    globalResizeObserver.observe(wrap);
  }
})();

function clearActiveLayer(){
  if(!layers[activeLayer]) return;
  for(let y=0;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      layers[activeLayer].tiles[y][x] = { tx:-1, ty:-1 };
    }
  }
  draw();
}

function draw(){
  // clear & set transform
  mapCtx.setTransform(1,0,0,1,0,0);
  mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
  mapCtx.setTransform(scale,0,0,scale,offsetX,offsetY);

  // background
  mapCtx.fillStyle = '#070707';
  mapCtx.fillRect(0,0,mapWidth*tileSize, mapHeight*tileSize);

  // draw layers bottom->top
  for(let li=0; li<layers.length; li++){
    const L = layers[li];
    if(!L.visible) continue;
    if(!tilesetImage) continue; // none to draw
    const across = Math.max(1, Math.floor(tilesetImage.width / tileSize));
    for(let y=0;y<mapHeight;y++){
      for(let x=0;x<mapWidth;x++){
        const cell = L.tiles[y][x];
        if(cell.tx >= 0) {
          const sx = cell.tx * tileSize;
          const sy = cell.ty * tileSize;
          mapCtx.drawImage(tilesetImage, sx, sy, tileSize, tileSize, x*tileSize, y*tileSize, tileSize, tileSize);
        }
      }
    }
  }

  // grid
  if(showGrid){
    mapCtx.strokeStyle = 'rgba(255,255,255,0.06)';
    mapCtx.lineWidth = 1/scale;
    for(let x=0;x<=mapWidth; x++){
      mapCtx.beginPath();
      mapCtx.moveTo(x*tileSize, 0);
      mapCtx.lineTo(x*tileSize, mapHeight*tileSize);
      mapCtx.stroke();
    }
    for(let y=0;y<=mapHeight; y++){
      mapCtx.beginPath();
      mapCtx.moveTo(0, y*tileSize);
      mapCtx.lineTo(mapWidth*tileSize, y*tileSize);
      mapCtx.stroke();
    }
  }

  // border
  mapCtx.lineWidth = 2/scale;
  mapCtx.strokeStyle = 'rgba(255,255,255,0.08)';
  mapCtx.strokeRect(0,0,mapWidth*tileSize,mapHeight*tileSize);

  // active layer tint overlay
  if(layers[activeLayer] && layerPreview) {
    mapCtx.fillStyle = 'rgba(50,160,255,0.03)';
    mapCtx.fillRect(0,0,mapWidth*tileSize, mapHeight*tileSize);
  }

  // New: Draw spawn point marker
  if (spawnPoint.x >= 0 && spawnPoint.y >= 0) {
    mapCtx.fillStyle = 'rgba(255, 0, 0, 0.8)';
    mapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    mapCtx.lineWidth = 2 / scale;
    const centerX = (spawnPoint.x + 0.5) * tileSize;
    const centerY = (spawnPoint.y + 0.5) * tileSize;
    const radius = tileSize / 3;
    mapCtx.beginPath();
    mapCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    mapCtx.fill();
    mapCtx.stroke();
  }

  // reset transform for preview overlays
  mapCtx.setTransform(1,0,0,1,0,0);
  drawPreviewClear();
  updateStatus();
}

/* ---------- Preview (cursor following) ---------- */
function drawPreviewAt(e){
  previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  const rect = mapCanvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const worldX = (sx - offsetX) / scale;
  const worldY = (sy - offsetY) / scale;
  const tx = Math.floor(worldX / tileSize);
  const ty = Math.floor(worldY / tileSize);

  if(tx < -10 || ty < -10 || tx > mapWidth+10 || ty > mapHeight+10) return;

  previewCtx.save();
  previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  previewCtx.translate(offsetX, offsetY);
  previewCtx.scale(scale, scale);

  if (spawnMode) {
    // Preview for spawn mode: single tile highlight with marker
    previewCtx.fillStyle = 'rgba(255, 0, 0, 0.2)';
    previewCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
    previewCtx.lineWidth = 2 / scale;
    previewCtx.fillRect(tx * tileSize, ty * tileSize, tileSize, tileSize);
    previewCtx.strokeRect(tx * tileSize, ty * tileSize, tileSize, tileSize);

    const centerX = (tx + 0.5) * tileSize;
    const centerY = (ty + 0.5) * tileSize;
    const radius = tileSize / 3;
    previewCtx.beginPath();
    previewCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    previewCtx.stroke();
  } else {
    const brush = parseInt(document.getElementById('brushSize').value,10) || 1;
    const half = Math.floor((brush-1)/2);

    previewCtx.fillStyle = 'rgba(255,255,255,0.06)';
    previewCtx.strokeStyle = 'rgba(255,255,255,0.22)';
    previewCtx.lineWidth = 2/scale;

    for(let by=0; by<brush; by++){
      for(let bx=0; bx<brush; bx++){
        const x = tx + bx - half;
        const y = ty + by - half;
        if(x < 0 || y < 0 || x >= mapWidth || y >= mapHeight) continue;
        previewCtx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
        previewCtx.strokeRect(x*tileSize, y*tileSize, tileSize, tileSize);
      }
    }

    if(selectedTile >= 0 && tilesetImage){
      const across = Math.max(1, Math.floor(tilesetImage.width / tileSize));
      const sxTile = (selectedTile % across) * tileSize;
      const syTile = Math.floor(selectedTile / across) * tileSize;
      previewCtx.globalAlpha = 0.9;
      previewCtx.drawImage(tilesetImage, sxTile, syTile, tileSize, tileSize,
                          tx*tileSize, ty*tileSize, tileSize, tileSize);
      previewCtx.globalAlpha = 1.0;
    }
  }
  previewCtx.restore();
}

function drawPreviewClear(){
  // we clear on demand already
  previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
}

/* ---------- Save / Load JSON ---------- */
function buildExportJSON(){
  return {
    name: "MyMap",
    width: mapWidth,
    height: mapHeight,
    tile_size: tileSize,
    spawn_point: spawnPoint.x >= 0 ? { x: spawnPoint.x, y: spawnPoint.y } : null,
    layers: layers.map(L => ({
      name: L.name,
      visible: !!L.visible,
      tiles: L.tiles.map(row => row.map(cell => ({ tx: cell.tx, ty: cell.ty })))
    }))
  };
}

function downloadJSON(){
  const obj = buildExportJSON();
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (obj.name || 'map') + '.json';
  document.body.appendChild(a);
  a.click();
  a.remove();
  try { URL.revokeObjectURL(url); } catch(_) {}
}

function loadJSONFromFile(e){
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    try {
      const j = JSON.parse(evt.target.result);
      loadFromJSONObj(j);
    } catch(err) {
      alert('Invalid JSON file');
      console.error(err);
    }
  };
  reader.readAsText(f);
}

function loadFromJSONObj(j){
  tileSize = j.tile_size || tileSize;
  tileSizeInput.value = tileSize;
  mapWidth = j.width || mapWidth; mapHeight = j.height || mapHeight;
  spawnPoint = j.spawn_point && j.spawn_point.x >= 0 && j.spawn_point.y >= 0 ? { x: j.spawn_point.x, y: j.spawn_point.y } : { x: -1, y: -1 };
  layers = [];
  if(Array.isArray(j.layers) && j.layers.length){
    for(const L of j.layers){
      if(L.tiles && Array.isArray(L.tiles) && L.tiles.length === mapHeight) {
        // normalize tiles to ensure tx/ty exist
        const normalized = [];
        for(let y=0;y<mapHeight;y++){
          const row = [];
          for(let x=0;x<mapWidth;x++){
            const c = (L.tiles[y] && L.tiles[y][x]) ? L.tiles[y][x] : { tx:-1, ty:-1 };
            row.push({ tx: c.tx ?? -1, ty: c.ty ?? -1 });
          }
          normalized.push(row);
        }
        layers.push({ name: L.name || 'Layer', visible: !!L.visible, tiles: normalized });
      } else {
        layers.push(createEmptyLayer(L.name || 'Layer'));
      }
    }
  } else {
    layers.push(createEmptyLayer('Layer 0'));
  }

  activeLayer = Math.max(0, layers.length-1);
  document.getElementById('mapWidth').value = mapWidth;
  document.getElementById('mapHeight').value = mapHeight;
  resizeCanvases();
  refreshLayersUI();
  draw();
}

/* ---------- Utilities ---------- */
function updateStatus(){
  const spawnText = spawnPoint.x >= 0 ? `${spawnPoint.x},${spawnPoint.y}` : 'none';
  statusEl.textContent = `Selected tile: ${selectedTile} | Layer: ${layers[activeLayer] ? layers[activeLayer].name : '-'} (${activeLayer}) | Scale: ${Math.round(scale*100)}% | Spawn: ${spawnText}`;
}

/* ---------- Init defaults ---------- */
(function init(){
  createMap(mapWidth, mapHeight);
  if(!layers.length) layers.push(createEmptyLayer('Ground'));
  activeLayer = 0;
  refreshLayersUI();
  draw();
  resizeCanvases();
})();
</script>
</body>
</html>