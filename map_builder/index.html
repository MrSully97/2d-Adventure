<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Advanced Tile Map Builder</title>

  <!-- Tailwind CDN (for quick prototype) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* small helper so canvases stay crisp with pixel art */
    canvas { image-rendering: pixelated; }
  </style>
</head>
<body class="min-h-screen bg-gray-900 text-slate-100 font-sans">
  <div class="p-4 h-screen box-border flex gap-4">
    <!-- LEFT PANEL -->
    <aside class="w-80 bg-slate-800 rounded-xl p-4 flex-shrink-0 shadow-lg overflow-auto">
      <h2 class="text-white text-sm font-semibold mb-2">Tileset</h2>

      <label id="uploadTilesetBtn" class="block mb-2">
        <input id="tilesetInput" type="file" accept="image/*" class="hidden" multiple>
        <button type="button" class="w-full bg-slate-700 hover:bg-slate-600 text-slate-100 py-2 rounded-md flex items-center justify-center gap-2">
          <!-- heroicon: upload -->
          <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true"><path fill-rule="evenodd" d="M3 8a1 1 0 011-1h3V4a1 1 0 112 0v3h3a1 1 0 011 1v7a1 1 0 01-1 1H4a1 1 0 01-1-1V8z" clip-rule="evenodd"/></svg>
          Upload Tileset (e.g. 16Ã—16)
        </button>
      </label>

      <div class="mt-2 flex items-center gap-2">
        <select id="tilesetSelect" class="flex-1 bg-slate-800 rounded px-2 py-1 text-sm">
          <option value="-1">No tileset</option>
        </select>
        <button id="removeTileset" class="bg-red-600 hover:bg-red-500 px-2 py-1 rounded text-sm">Remove</button>
      </div>

      <div class="bg-slate-900 rounded-md p-2 border border-slate-700">
        <canvas id="tilesetCanvas" class="w-full block border border-slate-700 rounded-sm"></canvas>
      </div>

      <div class="mt-3 grid grid-cols-2 gap-3">
        <div>
          <label class="text-xs text-slate-400">Tile Size</label>
          <input id="tileSizeInput" type="number" value="16" min="4" max="128" class="w-full mt-1 bg-slate-800 rounded px-2 py-1 text-sm">
        </div>
        <div>
          <label class="text-xs text-slate-400">Brush</label>
          <select id="brushSize" class="w-full mt-1 bg-slate-800 rounded px-2 py-1 text-sm">
            <option value="1">1Ã—1</option>
            <option value="2">2Ã—2</option>
            <option value="3">3Ã—3</option>
          </select>
        </div>
      </div>

      <h2 class="text-white text-sm font-semibold mt-4 mb-2">Layers</h2>
      <div class="flex gap-2 mb-2">
        <button id="addLayer" class="flex-1 bg-emerald-600 hover:bg-emerald-500 py-1 rounded text-sm">+ Add</button>
        <button id="removeLayer" class="flex-1 bg-red-600 hover:bg-red-500 py-1 rounded text-sm">Remove</button>
      </div>
      <div class="flex gap-2 mb-3">
        <button id="layerUp" class="w-1/2 bg-slate-700 py-1 rounded text-sm">â–²</button>
        <button id="layerDown" class="w-1/2 bg-slate-700 py-1 rounded text-sm">â–¼</button>
      </div>

      <div id="layersList" class="space-y-2 max-h-48 overflow-auto"></div>

      <div class="mt-3">
        <label class="text-xs text-slate-400">Map Size</label>
        <div class="mt-1 flex gap-2 items-center">
          <input id="mapWidth" type="number" value="30" class="w-20 bg-slate-800 rounded px-2 py-1 text-sm">
          <input id="mapHeight" type="number" value="20" class="w-20 bg-slate-800 rounded px-2 py-1 text-sm">
          <button id="createMap" class="ml-auto bg-indigo-600 hover:bg-indigo-500 px-3 py-1 rounded text-sm">Create</button>
        </div>
      </div>

      <h2 class="text-white text-sm font-semibold mt-4 mb-2">File</h2>
      <div class="flex gap-2">
        <button id="downloadJson" class="flex-1 bg-slate-700 hover:bg-slate-600 py-2 rounded text-sm">Download JSON</button>
        <label id="loadJsonLabel" class="w-1/3">
          <input id="loadJsonInput" type="file" accept=".json" class="hidden">
          <button class="w-full bg-slate-700 hover:bg-slate-600 py-2 rounded text-sm">Load</button>
        </label>
      </div>

      <div class="mt-3 text-xs text-slate-400 space-y-1">
        <div>Pan: middle-mouse drag OR hold <kbd class="bg-slate-800 px-1 rounded">Space</kbd> + left-drag</div>
        <div>Zoom: mouse wheel</div>
        <div>Erase: right-click</div>
        <div>Drag paint: left-button drag</div>
      </div>

      <div class="mt-4 text-xs text-slate-500">Advanced Tile Map Builder â€” dynamic layers, zoom, pan, save/load</div>
    </aside>

    <!-- RIGHT / CANVAS -->
    <main class="flex-1 flex flex-col gap-3">
      <div class="flex items-center gap-3">
        <div class="flex gap-2" id="toolbar">
          <button id="toggleGrid" class="bg-slate-700 hover:bg-slate-600 px-3 py-1 rounded text-sm flex items-center gap-2">
            <!-- grid icon -->
            <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor"><path d="M3 3h4v4H3V3zm6 0h4v4H9V3zM3 9h4v4H3V9zm6 0h4v4H9V9zM3 15h4v2H3v-2zm6 0h4v2H9v-2z"/></svg> Grid
          </button>
          <button id="toggleLayerPreview" class="bg-slate-700 hover:bg-slate-600 px-3 py-1 rounded text-sm flex items-center gap-2">
            Preview
          </button>
          <button id="clearLayer" class="bg-yellow-600 hover:bg-yellow-500 px-3 py-1 rounded text-sm">Clear Layer</button>
          <button id="fillLayer" class="bg-blue-600 hover:bg-blue-500 px-3 py-1 rounded text-sm">Fill Layer</button>
          <button id="spawnTool" class="bg-slate-700 hover:bg-slate-600 px-3 py-1 rounded text-sm flex items-center gap-2">
            <!-- spawn icon (simple target) -->
            <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0-2a6 6 0 100-12 6 6 0 000 12zm0-2a4 4 0 100-8 4 4 0 000 8z" clip-rule="evenodd"/></svg> Spawn
          </button>
        </div>

        <div class="ml-auto text-sm text-slate-400" id="status">Selected tile: - | Layer: - | Scale: 100%</div>
      </div>

      <div id="mapContainer" class="flex-1 bg-slate-900 rounded-xl p-3 overflow-hidden">
        <div id="canvasWrap" class="bg-black rounded w-full h-full relative flex items-center justify-center">
          <canvas id="mapCanvas" width="800" height="600" class="absolute inset-0"></canvas>
          <canvas id="preview" width="800" height="600" class="absolute inset-0 pointer-events-none"></canvas>
        </div>
      </div>

      <div class="flex items-center gap-3">
        <div class="text-xs text-slate-400">Tileset:</div>
        <div id="tilesetInfo" class="text-xs text-slate-300">No tileset loaded</div>
      </div>
    </main>
  </div>

<script>
/* ==========================
   Advanced Tile Map Builder
   Tailwind + memory fixes
   + Spawn Point Feature
   ========================== */

const tilesetInput = document.getElementById('tilesetInput');
const uploadTilesetBtn = document.getElementById('uploadTilesetBtn');
const tilesetCanvas = document.getElementById('tilesetCanvas');
const tilesetCtx = tilesetCanvas.getContext('2d');
const tilesetSelect = document.getElementById('tilesetSelect');
const removeTilesetBtn = document.getElementById('removeTileset');

const tileSizeInput = document.getElementById('tileSizeInput');
let tileSize = parseInt(tileSizeInput.value, 10);

// multiple tilesets support
let tilesets = []; // { name, image, objectURL }
let activeTilesetIndex = -1;
let selectedTilesetIndex = -1;
let selectedTile = -1;
let tilesAcrossHeight = { across:0, rows:0 };
let currentTilesetObjectURLs = []; // track to revoke

uploadTilesetBtn.addEventListener('click', ()=> tilesetInput.click());
tilesetInput.addEventListener('change', handleTilesetUpload);
tilesetSelect.addEventListener('change', ()=> {
  const idx = parseInt(tilesetSelect.value,10);
  setActiveTileset(idx);
});
removeTilesetBtn.addEventListener('click', ()=> {
  if(activeTilesetIndex < 0) return;
  if(!confirm('Remove selected tileset?')) return;
  // revoke url if present
  const t = tilesets[activeTilesetIndex];
  if(t && t.objectURL) { try{ URL.revokeObjectURL(t.objectURL); }catch(_){} }
  tilesets.splice(activeTilesetIndex,1);
  if(tilesets.length === 0) activeTilesetIndex = -1;
  else activeTilesetIndex = Math.max(0, activeTilesetIndex-1);
  refreshTilesetSelect();
  redrawTileset();
});
tileSizeInput.addEventListener('change', e=>{
  tileSize = Math.max(4, parseInt(e.target.value)||16);
  redrawTileset();
  rebuildTileWorldCoords();
});

const mapCanvas = document.getElementById('mapCanvas');
const mapCtx = mapCanvas.getContext('2d');
const previewCanvas = document.getElementById('preview');
const previewCtx = previewCanvas.getContext('2d');

let mapWidth = parseInt(document.getElementById('mapWidth').value,10);
let mapHeight = parseInt(document.getElementById('mapHeight').value,10);

// normalized layers: { name, visible, tiles: [ [ {tx,ty}, ... ], ... ], _cache: offscreen canvas }
let layers = [];
let activeLayer = 0;
let layerCaches = []; // offscreen canvases for each layer

const layersList = document.getElementById('layersList');
document.getElementById('addLayer').addEventListener('click', addLayer);
document.getElementById('removeLayer').addEventListener('click', removeLayer);
document.getElementById('layerUp').addEventListener('click', ()=> moveLayer(-1));
document.getElementById('layerDown').addEventListener('click', ()=> moveLayer(1));
document.getElementById('createMap').addEventListener('click', ()=> {
  mapWidth = parseInt(document.getElementById('mapWidth').value,10) || mapWidth;
  mapHeight = parseInt(document.getElementById('mapHeight').value,10) || mapHeight;
  createMap(mapWidth, mapHeight);
});

document.getElementById('downloadJson').addEventListener('click', downloadJSON);
document.getElementById('loadJsonLabel').addEventListener('click', ()=> document.getElementById('loadJsonInput').click());
document.getElementById('loadJsonInput').addEventListener('change', loadJSONFromFile);

document.getElementById('brushSize').addEventListener('change', ()=> {});
document.getElementById('toggleGrid').addEventListener('click', ()=> { showGrid = !showGrid; draw(); });
document.getElementById('toggleLayerPreview').addEventListener('click', ()=> { layerPreview = !layerPreview; draw(); });
document.getElementById('clearLayer').addEventListener('click', ()=> { if(confirm('Clear active layer?')) clearActiveLayer(); });
document.getElementById('fillLayer').addEventListener('click', ()=> { if(selectedTile >= 0) fillActiveLayer(); else alert('Please select a tile first'); });

const statusEl = document.getElementById('status');
const tilesetInfo = document.getElementById('tilesetInfo');

let showGrid = true;
let layerPreview = true;

// New: Spawn point feature
let spawnPoint = { x: -1, y: -1 };
let spawnMode = false;
const spawnTool = document.getElementById('spawnTool');
spawnTool.addEventListener('click', () => {
  spawnMode = !spawnMode;
  spawnTool.classList.toggle('bg-indigo-600', spawnMode);
  spawnTool.classList.toggle('bg-slate-700', !spawnMode);
  mapCanvas.style.cursor = spawnMode ? 'pointer' : (spaceDown ? 'grab' : 'crosshair');
});

/* ---------- Map transform (zoom/pan) ---------- */
let scale = 1.0;
let offsetX = 0;
let offsetY = 0;
let isPanning = false;
let panStart = {x:0,y:0, ox:0, oy:0};
let spaceDown = false;
window.addEventListener('keydown', e=> { if(e.code==='Space') { spaceDown = true; mapCanvas.style.cursor = spawnMode ? 'pointer' : 'grab'; } });
window.addEventListener('keyup', e=> { if(e.code==='Space') { spaceDown = false; mapCanvas.style.cursor = spawnMode ? 'pointer' : 'crosshair'; } });

// wheel zoom (preserve world point under cursor)
mapCanvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const rect = mapCanvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const wheel = e.deltaY < 0 ? 1.12 : 0.88;
  const worldX = (mouseX - offsetX) / scale;
  const worldY = (mouseY - offsetY) / scale;
  scale = Math.min(8, Math.max(0.2, scale * wheel));
  offsetX = mouseX - worldX * scale;
  offsetY = mouseY - worldY * scale;
  updateStatus();
  draw();
}, {passive:false});

/* ---------- Painting state ---------- */
let isPainting = false;
let isErasing = false;

mapCanvas.addEventListener('mousedown', e=>{
  // left = paint, middle = pan, right = erase
  if(e.button === 1 || (e.button === 0 && spaceDown)) {
    isPanning = true;
    panStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY };
    mapCanvas.style.cursor = 'grabbing';
    return;
  }

  if(spawnMode) {
    if(e.button === 0) {
      setSpawnAtEvent(e);
      return;
    } else if(e.button === 2) {
      e.preventDefault();
      spawnPoint = { x: -1, y: -1 };
      draw();
      updateStatus();
      return;
    }
  }

  if(e.button === 2) {
    e.preventDefault();
    isErasing = true;
    paintAtEvent(e, true);
    return;
  }

  if(e.button === 0) {
    isPainting = true;
    paintAtEvent(e, false);
  }
});

window.addEventListener('mouseup', e=>{
  if(isPanning) { isPanning = false; mapCanvas.style.cursor = spaceDown ? 'grab' : 'crosshair'; }
  isPainting = false;
  isErasing = false;
});

mapCanvas.addEventListener('mousemove', e=>{
  if(isPanning) {
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    offsetX = panStart.ox + dx;
    offsetY = panStart.oy + dy;
    draw();
    updateStatus();
    return;
  }

  if(isPainting) paintAtEvent(e, false);
  if(isErasing) paintAtEvent(e, true);

  drawPreviewAt(e);
});

mapCanvas.addEventListener('contextmenu', e => { e.preventDefault(); });
mapCanvas.addEventListener('mouseleave', ()=> { drawPreviewClear(); });

/* ---------- Tileset interaction ---------- */
tilesetCanvas.addEventListener('click', e=>{
  const t = tilesets[activeTilesetIndex];
  if(!t || !t.image) return;
  // Map mouse event (client coords) to canvas internal pixels in case CSS scales the canvas
  const rect = tilesetCanvas.getBoundingClientRect();
  const scaleX = tilesetCanvas.width / rect.width;
  const scaleY = tilesetCanvas.height / rect.height;
  const clickX = (e.clientX - rect.left) * scaleX;
  const clickY = (e.clientY - rect.top) * scaleY;
  const tx = Math.floor(clickX / tileSize);
  const ty = Math.floor(clickY / tileSize);
  const across = Math.max(1, Math.floor(t.image.width / tileSize));
  selectedTile = ty * across + tx;
  selectedTilesetIndex = activeTilesetIndex;
  drawTileset();
  updateStatus();
});

/* handle file upload - revoke previous object URLs to prevent leaks */
function handleTilesetUpload(e){
  const files = Array.from(e.target.files || []);
  if(files.length === 0) return;
  files.forEach(file => addTileset(file));
  // clear input to allow re-upload of same file later
  tilesetInput.value = '';
}

function addTileset(file){
  const img = new Image();
  const url = URL.createObjectURL(file);
  currentTilesetObjectURLs.push(url);
  img.onload = () => {
    try { URL.revokeObjectURL(url); } catch(_) {}
    // push tileset record
    tilesets.push({ name: file.name || `tileset ${tilesets.length}`, image: img, objectURL: null });
    activeTilesetIndex = tilesets.length - 1;
    selectedTilesetIndex = activeTilesetIndex;
    selectedTile = -1;
    refreshTilesetSelect();
    redrawTileset();
    draw();
  };
  img.onerror = () => {
    alert('Failed to load image: ' + (file.name || 'unknown'));
    try { URL.revokeObjectURL(url); } catch(_) {}
  };
  img.src = url;
}

function refreshTilesetSelect(){
  tilesetSelect.innerHTML = '<option value="-1">No tileset</option>';
  tilesets.forEach((t,i) => {
    const opt = document.createElement('option');
    opt.value = String(i);
    opt.textContent = `${i}: ${t.name}`;
    tilesetSelect.appendChild(opt);
  });
  tilesetSelect.value = activeTilesetIndex >= 0 ? String(activeTilesetIndex) : '-1';
}

function setActiveTileset(idx){
  activeTilesetIndex = (isNaN(idx) ? -1 : idx);
  if(activeTilesetIndex < 0 || !tilesets[activeTilesetIndex]) {
    tilesetCanvas.width = 0; tilesetCanvas.height = 0;
    drawTileset();
    return;
  }
  selectedTilesetIndex = activeTilesetIndex;
  redrawTileset();
}

function redrawTileset(){
  const t = tilesets[activeTilesetIndex];
  if(!t || !t.image) {
    tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
    tilesetInfo.textContent = 'No tileset loaded';
    return;
  }
  tilesetCanvas.width = t.image.width;
  tilesetCanvas.height = t.image.height;
  tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
  tilesetCtx.drawImage(t.image,0,0);
  drawTileset();
}

function drawTileset(){
  const t = tilesets[activeTilesetIndex];
  if(!t || !t.image) {
    tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
    tilesetInfo.textContent = 'No tileset loaded';
    return;
  }
  tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
  tilesetCtx.drawImage(t.image,0,0);
  const across = Math.max(1, Math.floor(t.image.width / tileSize));
  tilesAcrossHeight.across = across;
  tilesAcrossHeight.rows = Math.ceil(t.image.height / tileSize);
  tilesetInfo.textContent = `${t.image.width}Ã—${t.image.height} â€” ${across} across Ã— ${tilesAcrossHeight.rows} rows`;

  if(selectedTile >= 0 && selectedTilesetIndex === activeTilesetIndex) {
    const sx = (selectedTile % across) * tileSize;
    const sy = Math.floor(selectedTile / across) * tileSize;
    tilesetCtx.lineWidth = 2;
    tilesetCtx.strokeStyle = 'yellow';
    tilesetCtx.strokeRect(sx+1, sy+1, tileSize-2, tileSize-2);
  }
}

/* ---------- Map Data / Layers ---------- */
function createEmptyLayer(name){
  const arr = [];
  for(let y=0;y<mapHeight;y++){
    const row = [];
    for(let x=0;x<mapWidth;x++){
      row.push({ tileset: -1, tx: -1, ty: -1 });
    }
    arr.push(row);
  }
  return { name: name||`Layer ${layers.length}`, visible:true, tiles: arr };
}

/* Layer caching for performance */
function initLayerCaches(){
  layerCaches = layers.map(() => {
    const canvas = document.createElement('canvas');
    canvas.width = mapWidth * tileSize;
    canvas.height = mapHeight * tileSize;
    return { canvas, isDirty: true };
  });
}

function invalidateLayerCache(layerIdx){
  if(layerCaches[layerIdx]) {
    layerCaches[layerIdx].isDirty = true;
  }
}

function invalidateAllLayerCaches(){
  for(const cache of layerCaches) {
    cache.isDirty = true;
  }
}

function redrawLayerCache(layerIdx){
  const cacheRec = layerCaches[layerIdx];
  if(!cacheRec) return;
  const L = layers[layerIdx];
  const cache = cacheRec;
  const ctx = cache.canvas.getContext('2d');
  ctx.clearRect(0, 0, cache.canvas.width, cache.canvas.height);

  for(let y=0; y<mapHeight; y++){
    for(let x=0; x<mapWidth; x++){
      const cell = L.tiles[y][x];
      if(!cell || cell.tx < 0) continue;
      const tsIdx = (cell.tileset ?? 0);
      const ts = tilesets[tsIdx];
      if(!ts || !ts.image) continue;
      const sx = cell.tx * tileSize;
      const sy = cell.ty * tileSize;
      ctx.drawImage(ts.image, sx, sy, tileSize, tileSize, x*tileSize, y*tileSize, tileSize, tileSize);
    }
  }
  cache.isDirty = false;
}

function createMap(w,h){
  mapWidth = w; mapHeight = h;
  if(layers.length === 0) {
    layers.push(createEmptyLayer('Ground'));
    activeLayer = 0;
  } else {
    for(const L of layers){
      const newTiles = [];
      for(let y=0;y<mapHeight;y++){
        const row = [];
        for(let x=0;x<mapWidth;x++){
          if(L.tiles[y] && L.tiles[y][x]) {
            const c = L.tiles[y][x];
            row.push({ tileset: (c.tileset ?? -1), tx: (c.tx ?? -1), ty: (c.ty ?? -1) });
          } else {
            row.push({ tileset: -1, tx: -1, ty: -1 });
          }
        }
        newTiles.push(row);
      }
      L.tiles = newTiles;
    }
  }
  // Reset spawn if out of bounds
  if (spawnPoint.x >= mapWidth || spawnPoint.y >= mapHeight) {
    spawnPoint = { x: -1, y: -1 };
  }
  initLayerCaches();
  resizeCanvases();
  refreshLayersUI();
  draw();
}

function rebuildTileWorldCoords() {
  // kept for backwards compatibility with earlier code paths that stored x/y; here we don't store world x/y
}

/* Layer management */
function addLayer(){
  const name = prompt('Layer name', `Layer ${layers.length}`);
  layers.splice(activeLayer+1, 0, createEmptyLayer(name));
  activeLayer = activeLayer+1;
  initLayerCaches();
  refreshLayersUI();
  draw();
}

function removeLayer(){
  if(layers.length === 0) return;
  if(!confirm('Remove active layer?')) return;
  layers.splice(activeLayer,1);
  activeLayer = Math.max(0, activeLayer-1);
  initLayerCaches();
  refreshLayersUI();
  draw();
}

function moveLayer(dir){
  const idx = activeLayer;
  const to = idx + dir;
  if(to < 0 || to >= layers.length) return;
  const tmp = layers[to];
  layers[to] = layers[idx];
  layers[idx] = tmp;
  activeLayer = to;
  refreshLayersUI();
  draw();
}

function refreshLayersUI(){
  // clear and re-create items
  layersList.innerHTML = '';
  for(let i=layers.length-1;i>=0;i--){ // show top first
    const L = layers[i];
    const item = document.createElement('div');
    item.className = 'flex items-center gap-2 p-2 rounded bg-slate-800';
    item.dataset.idx = i;

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = !!L.visible;
    cb.title = 'visible';
    cb.addEventListener('change', ()=> {
      L.visible = cb.checked;
      draw();
    });

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.value = L.name;
    nameInput.className = 'bg-transparent border-0 text-sm text-slate-100 w-full';
    nameInput.addEventListener('change', ()=> { L.name = nameInput.value; });

    const eyeBtn = document.createElement('button');
    eyeBtn.className = 'ml-2 text-sm';
    eyeBtn.title = 'Select layer';
    eyeBtn.innerHTML = 'ðŸ‘ï¸';
    eyeBtn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      L.visible = !L.visible;
      cb.checked = L.visible;
      draw();
    });

    item.appendChild(cb);
    item.appendChild(nameInput);
    item.appendChild(eyeBtn);

    if(i === activeLayer) {
      item.classList.add('ring', 'ring-amber-400', 'ring-opacity-20');
    }

    item.addEventListener('click', ()=> {
      activeLayer = i;
      refreshLayersUI();
      updateStatus();
      draw();
    });

    layersList.appendChild(item);
  }
  updateStatus();
}

/* ---------- Painting functions ---------- */
function paintAtEvent(e, erase){
  if(!layers[activeLayer]) return;
  const rect = mapCanvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const worldX = (sx - offsetX) / scale;
  const worldY = (sy - offsetY) / scale;
  const tx = Math.floor(worldX / tileSize);
  const ty = Math.floor(worldY / tileSize);

  let tileCoord = null;
  if(!erase && selectedTile >= 0 && tilesets[selectedTilesetIndex] && tilesets[selectedTilesetIndex].image) {
    const ts = tilesets[selectedTilesetIndex];
    const across = Math.max(1, Math.floor(ts.image.width / tileSize));
    tileCoord = { tileset: selectedTilesetIndex, tx: selectedTile % across, ty: Math.floor(selectedTile / across) };
  }

  applyBrushAt(tx, ty, erase ? null : tileCoord);
  draw();
}

function applyBrushAt(tileX, tileY, tileCoord){
  if(!layers[activeLayer]) return;
  const brush = parseInt(document.getElementById('brushSize').value,10) || 1;
  const half = Math.floor((brush-1)/2);
  for(let by=0; by<brush; by++){
    for(let bx=0; bx<brush; bx++){
      const x = tileX + bx - half;
      const y = tileY + by - half;
      if(x < 0 || y < 0 || x >= mapWidth || y >= mapHeight) continue;
      if(tileCoord) {
        layers[activeLayer].tiles[y][x] = { tileset: (tileCoord.tileset ?? 0), tx: tileCoord.tx, ty: tileCoord.ty };
      } else {
        layers[activeLayer].tiles[y][x] = { tileset: -1, tx:-1, ty:-1 };
      }
    }
  }
  invalidateLayerCache(activeLayer);
}

// New: Set spawn point at mouse event
function setSpawnAtEvent(e) {
  const rect = mapCanvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const worldX = (sx - offsetX) / scale;
  const worldY = (sy - offsetY) / scale;
  const tx = Math.floor(worldX / tileSize);
  const ty = Math.floor(worldY / tileSize);
  if (tx >= 0 && ty >= 0 && tx < mapWidth && ty < mapHeight) {
    spawnPoint = { x: tx, y: ty };
    draw();
    updateStatus();
  }
}

/* ---------- Draw map ---------- */
function resizeCanvases(){
  const wrap = document.getElementById('canvasWrap');
  // make map canvas match container pixel size for crisp rendering
  mapCanvas.width = Math.max(200, Math.floor(wrap.clientWidth));
  mapCanvas.height = Math.max(200, Math.floor(wrap.clientHeight));
  previewCanvas.width = mapCanvas.width;
  previewCanvas.height = mapCanvas.height;
  
  // Resize layer cache canvases
  for(const cache of layerCaches) {
    cache.canvas.width = mapWidth * tileSize;
    cache.canvas.height = mapHeight * tileSize;
    cache.isDirty = true;
  }
}
window.addEventListener('resize', ()=> { resizeCanvases(); draw(); });

let globalResizeObserver = null;
(function attachObserverOnce(){
  const wrap = document.getElementById('canvasWrap');
  if(!globalResizeObserver) {
    globalResizeObserver = new ResizeObserver(() => { resizeCanvases(); draw(); });
    globalResizeObserver.observe(wrap);
  }
})();

function clearActiveLayer(){
  if(!layers[activeLayer]) return;
  for(let y=0;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      layers[activeLayer].tiles[y][x] = { tileset:-1, tx:-1, ty:-1 };
    }
  }
  invalidateLayerCache(activeLayer);
  draw();
}

function fillActiveLayer(){
  if(!layers[activeLayer]) return;
  if(selectedTile < 0 || selectedTilesetIndex < 0) return;
  const ts = tilesets[selectedTilesetIndex];
  if(!ts || !ts.image) return;
  const across = Math.max(1, Math.floor(ts.image.width / tileSize));
  const tileCoord = { tileset: selectedTilesetIndex, tx: selectedTile % across, ty: Math.floor(selectedTile / across) };
  for(let y=0;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      layers[activeLayer].tiles[y][x] = { tileset: tileCoord.tileset, tx: tileCoord.tx, ty: tileCoord.ty };
    }
  }
  invalidateLayerCache(activeLayer);
  draw();
}

function draw(){
  // clear & set transform
  mapCtx.setTransform(1,0,0,1,0,0);
  mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
  mapCtx.setTransform(scale,0,0,scale,offsetX,offsetY);

  // background
  mapCtx.fillStyle = '#070707';
  mapCtx.fillRect(0,0,mapWidth*tileSize, mapHeight*tileSize);

  // draw layers bottom->top using cached canvases
  for(let li=0; li<layers.length; li++){
    const L = layers[li];
    if(!L.visible) continue;
    
    // Redraw cache if dirty
    if(layerCaches[li] && layerCaches[li].isDirty) {
      redrawLayerCache(li);
    }
    
    // Draw cached layer
    if(layerCaches[li]) {
      mapCtx.drawImage(layerCaches[li].canvas, 0, 0);
    }
  }

  // grid
  if(showGrid){
    mapCtx.strokeStyle = 'rgba(255,255,255,0.06)';
    mapCtx.lineWidth = 1/scale;
    for(let x=0;x<=mapWidth; x++){
      mapCtx.beginPath();
      mapCtx.moveTo(x*tileSize, 0);
      mapCtx.lineTo(x*tileSize, mapHeight*tileSize);
      mapCtx.stroke();
    }
    for(let y=0;y<=mapHeight; y++){
      mapCtx.beginPath();
      mapCtx.moveTo(0, y*tileSize);
      mapCtx.lineTo(mapWidth*tileSize, y*tileSize);
      mapCtx.stroke();
    }
  }

  // border
  mapCtx.lineWidth = 2/scale;
  mapCtx.strokeStyle = 'rgba(255,255,255,0.08)';
  mapCtx.strokeRect(0,0,mapWidth*tileSize,mapHeight*tileSize);

  // active layer tint overlay
  if(layers[activeLayer] && layerPreview) {
    mapCtx.fillStyle = 'rgba(50,160,255,0.03)';
    mapCtx.fillRect(0,0,mapWidth*tileSize, mapHeight*tileSize);
  }

  // New: Draw spawn point marker
  if (spawnPoint.x >= 0 && spawnPoint.y >= 0) {
    mapCtx.fillStyle = 'rgba(255, 0, 0, 0.8)';
    mapCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    mapCtx.lineWidth = 2 / scale;
    const centerX = (spawnPoint.x + 0.5) * tileSize;
    const centerY = (spawnPoint.y + 0.5) * tileSize;
    const radius = tileSize / 3;
    mapCtx.beginPath();
    mapCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    mapCtx.fill();
    mapCtx.stroke();
  }

  // reset transform for preview overlays
  mapCtx.setTransform(1,0,0,1,0,0);
  drawPreviewClear();
  updateStatus();
}

/* ---------- Preview (cursor following) ---------- */
function drawPreviewAt(e){
  previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  const rect = mapCanvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const worldX = (sx - offsetX) / scale;
  const worldY = (sy - offsetY) / scale;
  const tx = Math.floor(worldX / tileSize);
  const ty = Math.floor(worldY / tileSize);

  if(tx < -10 || ty < -10 || tx > mapWidth+10 || ty > mapHeight+10) return;

  previewCtx.save();
  previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  previewCtx.translate(offsetX, offsetY);
  previewCtx.scale(scale, scale);

  if (spawnMode) {
    // Preview for spawn mode: single tile highlight with marker
    previewCtx.fillStyle = 'rgba(255, 0, 0, 0.2)';
    previewCtx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
    previewCtx.lineWidth = 2 / scale;
    previewCtx.fillRect(tx * tileSize, ty * tileSize, tileSize, tileSize);
    previewCtx.strokeRect(tx * tileSize, ty * tileSize, tileSize, tileSize);

    const centerX = (tx + 0.5) * tileSize;
    const centerY = (ty + 0.5) * tileSize;
    const radius = tileSize / 3;
    previewCtx.beginPath();
    previewCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    previewCtx.stroke();
  } else {
    const brush = parseInt(document.getElementById('brushSize').value,10) || 1;
    const half = Math.floor((brush-1)/2);

    previewCtx.fillStyle = 'rgba(255,255,255,0.06)';
    previewCtx.strokeStyle = 'rgba(255,255,255,0.22)';
    previewCtx.lineWidth = 2/scale;

    for(let by=0; by<brush; by++){
      for(let bx=0; bx<brush; bx++){
        const x = tx + bx - half;
        const y = ty + by - half;
        if(x < 0 || y < 0 || x >= mapWidth || y >= mapHeight) continue;
        previewCtx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
        previewCtx.strokeRect(x*tileSize, y*tileSize, tileSize, tileSize);
      }
    }

    if(selectedTile >= 0 && tilesets[selectedTilesetIndex] && tilesets[selectedTilesetIndex].image){
      const ts = tilesets[selectedTilesetIndex];
      const across = Math.max(1, Math.floor(ts.image.width / tileSize));
      const sxTile = (selectedTile % across) * tileSize;
      const syTile = Math.floor(selectedTile / across) * tileSize;
      previewCtx.globalAlpha = 0.9;
      previewCtx.drawImage(ts.image, sxTile, syTile, tileSize, tileSize,
                          tx*tileSize, ty*tileSize, tileSize, tileSize);
      previewCtx.globalAlpha = 1.0;
    }
  }
  previewCtx.restore();
}

function drawPreviewClear(){
  // we clear on demand already
  previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
}

/* ---------- Save / Load JSON ---------- */
function buildExportJSON(){
  // Compress export: background (layer index 0) may be exported as a rectangle
  // defined by two diagonal points + tile if it's a uniform filled rectangle.
  // Other layers are exported as arrays of placed tiles only (x,y,tx,ty).
  const outLayers = layers.map((L, idx) => {
    // helper: collect all placed tiles
    const placed = [];
    for (let y = 0; y < mapHeight; y++) {
      for (let x = 0; x < mapWidth; x++) {
        const c = L.tiles[y][x];
        if (c && c.tx >= 0) placed.push({ x, y, tileset: (c.tileset ?? 0), tx: c.tx, ty: c.ty });
      }
    }

    if (idx === 0) {
      // Attempt to compress the background layer as a uniform filled rectangle.
      if (placed.length === 0) {
        return { name: L.name, visible: !!L.visible, tiles: [] };
      }

      let minX = mapWidth, minY = mapHeight, maxX = 0, maxY = 0;
      const first = placed[0];
      let sameTile = true;
      for (const p of placed) {
        if (p.x < minX) minX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.x > maxX) maxX = p.x;
        if (p.y > maxY) maxY = p.y;
        if (p.tx !== first.tx || p.ty !== first.ty) sameTile = false;
      }
      const expected = (maxX - minX + 1) * (maxY - minY + 1);
      const fullRect = (placed.length === expected);

      if (sameTile && fullRect) {
        return {
          name: L.name,
          visible: !!L.visible,
          tiles: {
            type: 'rect',
            p1: { x: minX, y: minY },
            p2: { x: maxX, y: maxY },
            tile: { tileset: first.tileset ?? 0, tx: first.tx, ty: first.ty }
          }
        };
      }

      // Not compressible -> return placed list
      return { name: L.name, visible: !!L.visible, tiles: placed };
    }

    // Other layers: export only placed tiles
    return { name: L.name, visible: !!L.visible, tiles: placed };
  });

  return {
    name: "MyMap",
    width: mapWidth,
    height: mapHeight,
    tile_size: tileSize,
    spawn_point: spawnPoint.x >= 0 ? { x: spawnPoint.x, y: spawnPoint.y } : null,
    tilesets: tilesets.map(t=>({ name: t.name })),
    layers: outLayers
  };
}

function downloadJSON(){
  const obj = buildExportJSON();
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (obj.name || 'map') + '.json';
  document.body.appendChild(a);
  a.click();
  a.remove();
  try { URL.revokeObjectURL(url); } catch(_) {}
}

function loadJSONFromFile(e){
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    try {
      const j = JSON.parse(evt.target.result);
      loadFromJSONObj(j);
    } catch(err) {
      alert('Invalid JSON file');
      console.error(err);
    }
  };
  reader.readAsText(f);
}

function loadFromJSONObj(j){
  tileSize = j.tile_size || tileSize;
  tileSizeInput.value = tileSize;
  mapWidth = j.width || mapWidth; mapHeight = j.height || mapHeight;
  spawnPoint = j.spawn_point && j.spawn_point.x >= 0 && j.spawn_point.y >= 0 ? { x: j.spawn_point.x, y: j.spawn_point.y } : { x: -1, y: -1 };
  layers = [];
  // tilesets cannot be auto-loaded from JSON; keep metadata if present
  if(Array.isArray(j.tilesets)) {
    tilesets = j.tilesets.map((t,i)=>({ name: t.name || `tileset ${i}`, image: null, objectURL: null }));
    activeTilesetIndex = tilesets.length ? 0 : -1;
    refreshTilesetSelect();
  } else {
    tilesets = [];
    activeTilesetIndex = -1;
    refreshTilesetSelect();
  }
  if (Array.isArray(j.layers) && j.layers.length) {
    for (const L of j.layers) {
      // produce a normalized grid filled with empty cells
      const normalized = [];
      for (let y = 0; y < mapHeight; y++) {
        const row = [];
        for (let x = 0; x < mapWidth; x++) row.push({ tileset: -1, tx: -1, ty: -1 });
        normalized.push(row);
      }

      if (!L.tiles) {
        layers.push({ name: L.name || 'Layer', visible: !!L.visible, tiles: normalized });
        continue;
      }

      // Case A: legacy full 2D array (rows)
      if (Array.isArray(L.tiles) && L.tiles.length === mapHeight && Array.isArray(L.tiles[0])) {
        for (let y = 0; y < mapHeight; y++) {
          for (let x = 0; x < mapWidth; x++) {
            const c = (L.tiles[y] && L.tiles[y][x]) ? L.tiles[y][x] : { tileset: -1, tx: -1, ty: -1 };
            normalized[y][x] = { tileset: (c.tileset ?? 0), tx: c.tx ?? -1, ty: c.ty ?? -1 };
          }
        }
        layers.push({ name: L.name || 'Layer', visible: !!L.visible, tiles: normalized });
        continue;
      }

      // Case B: compressed rect format
      if (L.tiles && typeof L.tiles === 'object' && L.tiles.type === 'rect') {
        const p1 = L.tiles.p1 || { x: 0, y: 0 };
        const p2 = L.tiles.p2 || { x: 0, y: 0 };
        const tile = L.tiles.tile || { tileset: -1, tx: -1, ty: -1 };
        const sx = Math.max(0, Math.min(p1.x, p2.x));
        const sy = Math.max(0, Math.min(p1.y, p2.y));
        const ex = Math.min(mapWidth - 1, Math.max(p1.x, p2.x));
        const ey = Math.min(mapHeight - 1, Math.max(p1.y, p2.y));
        for (let y = sy; y <= ey; y++) {
          for (let x = sx; x <= ex; x++) {
            normalized[y][x] = { tileset: (tile.tileset ?? 0), tx: tile.tx ?? -1, ty: tile.ty ?? -1 };
          }
        }
        layers.push({ name: L.name || 'Layer', visible: !!L.visible, tiles: normalized });
        continue;
      }

      // Case C: array of placed tiles [{x,y,tileset,tx,ty}, ...]
      if (Array.isArray(L.tiles)) {
        for (const p of L.tiles) {
          if (!p) continue;
          const x = Math.floor(p.x);
          const y = Math.floor(p.y);
          if (x >= 0 && y >= 0 && x < mapWidth && y < mapHeight) {
            normalized[y][x] = { tileset: (p.tileset ?? 0), tx: (p.tx ?? -1), ty: (p.ty ?? -1) };
          }
        }
        layers.push({ name: L.name || 'Layer', visible: !!L.visible, tiles: normalized });
        continue;
      }

      // Unknown format: push empty
      layers.push({ name: L.name || 'Layer', visible: !!L.visible, tiles: normalized });
    }
  } else {
    layers.push(createEmptyLayer('Layer 0'));
  }

  activeLayer = Math.max(0, layers.length-1);
  document.getElementById('mapWidth').value = mapWidth;
  document.getElementById('mapHeight').value = mapHeight;
  initLayerCaches();
  resizeCanvases();
  refreshLayersUI();
  draw();
}

/* ---------- Utilities ---------- */
function updateStatus(){
  const spawnText = spawnPoint.x >= 0 ? `${spawnPoint.x},${spawnPoint.y}` : 'none';
  const tilesetText = (selectedTilesetIndex >= 0 && tilesets[selectedTilesetIndex]) ? `${selectedTilesetIndex}:${tilesets[selectedTilesetIndex].name}` : 'none';
  statusEl.textContent = `Selected tile: ${selectedTile} (tileset ${tilesetText}) | Layer: ${layers[activeLayer] ? layers[activeLayer].name : '-'} (${activeLayer}) | Scale: ${Math.round(scale*100)}% | Spawn: ${spawnText}`;
}

/* ---------- Init defaults ---------- */
(function init(){
  createMap(mapWidth, mapHeight);
  if(!layers.length) layers.push(createEmptyLayer('Ground'));
  activeLayer = 0;
  refreshLayersUI();
  draw();
  resizeCanvases();
})();
</script>
</body>
</html>