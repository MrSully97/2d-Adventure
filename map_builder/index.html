<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Advanced Tile Map Builder</title>
  <style>
    :root {
      --bg: #141414;
      --panel: #1f1f1f;
      --muted: #9aa0a6;
      --accent: #2e8bff;
    }
    html,body { height:100%; margin:0; font-family:Inter,Arial,Helvetica,sans-serif; background:var(--bg); color:#eee; }
    .app { display:flex; gap:12px; padding:12px; height:100%; box-sizing:border-box; }
    .left, .right { background:var(--panel); padding:12px; border-radius:8px; box-shadow:0 6px 20px rgba(0,0,0,0.6); }
    .left { width:320px; flex-shrink:0; overflow:auto; }
    .right { flex:1; display:flex; flex-direction:column; gap:12px; overflow:hidden; }
    h2 { margin:6px 0 10px 0; font-size:16px; color:#fff; }
    label, button { font-size:13px; }
    input[type="number"] { width:70px; }
    #tilesetCanvas, #mapCanvas { display:block; background:#111; image-rendering:pixelated; border:1px solid #333; }
    #tilesetCanvas { width:100%; max-width:280px; height:auto; cursor:crosshair; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }
    .layers { margin-top:8px; max-height:260px; overflow:auto; border:1px solid #2a2a2a; padding:6px; border-radius:6px; }
    .layerItem { display:flex; gap:8px; align-items:center; padding:6px; border-radius:6px; margin-bottom:6px; background:rgba(255,255,255,0.02); }
    .layerItem.active { outline:2px solid rgba(200,200,50,0.12); }
    .layerItem input[type=text] { background:transparent; border:0; color: #eee; width:120px; }
    .small { font-size:12px; color:var(--muted); }
    .btn { background:#2b2b2b; color:#ddd; padding:6px 8px; border-radius:6px; border:1px solid #333; cursor:pointer; }
    .btn:hover { border-color:var(--accent); }
    #toolbar { display:flex; gap:8px; align-items:center; }
    .statusRow { display:flex; justify-content:space-between; gap:12px; align-items:center; margin-top:8px; font-size:13px; color:var(--muted); }
    .rightTop { display:flex; gap:12px; align-items:center; }
    #mapContainer { flex:1; background:#0d0d0d; border-radius:6px; display:flex; gap:12px; padding:12px; align-items:flex-start; overflow:hidden; }
    #canvasWrap { background:#0b0b0b; border-radius:6px; overflow:hidden; position:relative; flex:1; display:flex; align-items:center; justify-content:center; }
    #mapCanvas { cursor:crosshair; }
    #preview { position:absolute; pointer-events:none; z-index:20; }
    footer { font-size:12px; color:var(--muted); margin-top:6px; }
    input[type=file] { display:none; }
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <h2>Tileset</h2>
      <label class="btn" id="uploadTilesetBtn">Upload Tileset (16√ó16)</label>
      <input id="tilesetInput" type="file" accept="image/*">
      <div style="margin-top:10px;">
        <canvas id="tilesetCanvas"></canvas>
      </div>

      <div style="margin-top:12px;">
        <div class="controls">
          <div>
            <label class="small">Tile Size</label><br>
            <input id="tileSizeInput" type="number" value="16" min="4" max="128" style="width:80px;">
          </div>

          <div>
            <label class="small">Brush</label><br>
            <select id="brushSize">
              <option value="1">1√ó1</option>
              <option value="2">2√ó2</option>
              <option value="3">3√ó3</option>
            </select>
          </div>
        </div>
      </div>

      <h2 style="margin-top:14px;">Layers</h2>
      <div class="controls">
        <button class="btn" id="addLayer">+ Add Layer</button>
        <button class="btn" id="removeLayer">Remove</button>
        <button class="btn" id="layerUp">‚ñ≤</button>
        <button class="btn" id="layerDown">‚ñº</button>
      </div>

      <div class="layers" id="layersList"></div>

      <div style="margin-top:10px;">
        <label class="small">Map Size</label><br>
        Width: <input id="mapWidth" type="number" value="30"> Height: <input id="mapHeight" type="number" value="20">
        <button class="btn" id="createMap">Create</button>
      </div>

      <h2 style="margin-top:12px;">File</h2>
      <div class="controls">
        <button class="btn" id="downloadJson">Download JSON</button>
        <label class="btn" id="loadJsonLabel">Load JSON</label>
        <input id="loadJsonInput" type="file" accept=".json">
      </div>

      <div style="margin-top:12px;">
        <div class="small">Pan: middle-mouse drag OR hold SPACE + left-drag</div>
        <div class="small">Zoom: mouse wheel</div>
        <div class="small">Erase: right-click</div>
        <div class="small">Drag paint: left-button drag</div>
      </div>

      <footer>Advanced Tile Map Builder ‚Äî dynamic layers, zoom, pan, save/load</footer>
    </div>

    <div class="right">
      <div class="rightTop">
        <div id="toolbar">
          <button class="btn" id="toggleGrid">Toggle Grid</button>
          <button class="btn" id="toggleLayerPreview">Toggle Layer Preview</button>
          <button class="btn" id="clearLayer">Clear Layer</button>
        </div>

        <div style="margin-left:auto;">
          <div class="small" id="status">Selected tile: - | Layer: - | Scale: 100%</div>
        </div>
      </div>

      <div id="mapContainer">
        <div id="canvasWrap">
          <canvas id="mapCanvas" width="800" height="600"></canvas>
          <canvas id="preview" width="800" height="600"></canvas>
        </div>
      </div>

      <div style="display:flex; gap:12px; align-items:center;">
        <div class="small">Tileset:</div>
        <div id="tilesetInfo" class="small">No tileset loaded</div>
      </div>
    </div>
  </div>

<script>
/* ==========================
   Advanced Tile Map Builder
   ========================== */

const tilesetInput = document.getElementById('tilesetInput');
const uploadTilesetBtn = document.getElementById('uploadTilesetBtn');
const tilesetCanvas = document.getElementById('tilesetCanvas');
const tilesetCtx = tilesetCanvas.getContext('2d');

const tileSizeInput = document.getElementById('tileSizeInput');
let tileSize = parseInt(tileSizeInput.value, 10);

const tilesAcrossHeight = { across:0, rows:0 };
let tilesetImage = null;
let selectedTile = -1;

uploadTilesetBtn.addEventListener('click', ()=> tilesetInput.click());
tilesetInput.addEventListener('change', handleTilesetUpload);
tileSizeInput.addEventListener('change', e=>{
  tileSize = Math.max(4, parseInt(e.target.value)||16);
  redrawTileset();
});

const mapCanvas = document.getElementById('mapCanvas');
const mapCtx = mapCanvas.getContext('2d');
const previewCanvas = document.getElementById('preview');
const previewCtx = previewCanvas.getContext('2d');

let mapWidth = parseInt(document.getElementById('mapWidth').value,10);
let mapHeight = parseInt(document.getElementById('mapHeight').value,10);

let layers = []; // array of {name, visible, tiles: [ [ {id,x,y}, ... ], ... ] }
let activeLayer = 0;

const layersList = document.getElementById('layersList');
document.getElementById('addLayer').addEventListener('click', addLayer);
document.getElementById('removeLayer').addEventListener('click', removeLayer);
document.getElementById('layerUp').addEventListener('click', ()=> moveLayer(-1));
document.getElementById('layerDown').addEventListener('click', ()=> moveLayer(1));
document.getElementById('createMap').addEventListener('click', ()=> {
  mapWidth = parseInt(document.getElementById('mapWidth').value,10) || mapWidth;
  mapHeight = parseInt(document.getElementById('mapHeight').value,10) || mapHeight;
  createMap(mapWidth, mapHeight);
});

document.getElementById('downloadJson').addEventListener('click', downloadJSON);
document.getElementById('loadJsonLabel').addEventListener('click', ()=> document.getElementById('loadJsonInput').click());
document.getElementById('loadJsonInput').addEventListener('change', loadJSONFromFile);

document.getElementById('brushSize').addEventListener('change', ()=> {}); // used when painting
document.getElementById('toggleGrid').addEventListener('click', ()=> { showGrid = !showGrid; draw(); });
document.getElementById('toggleLayerPreview').addEventListener('click', ()=> { layerPreview = !layerPreview; draw(); });
document.getElementById('clearLayer').addEventListener('click', ()=> { if(confirm('Clear active layer?')) clearActiveLayer(); });

const statusEl = document.getElementById('status');
const tilesetInfo = document.getElementById('tilesetInfo');

let showGrid = true;
let layerPreview = true;

/* ---------- Map transform (zoom/pan) ---------- */
let scale = 1.0;
let offsetX = 0; // in screen px
let offsetY = 0;
let isPanning = false;
let panStart = {x:0,y:0, ox:0, oy:0};
let spaceDown = false;
window.addEventListener('keydown', e=> { if(e.code==='Space') { spaceDown = true; mapCanvas.style.cursor = 'grab'; } });
window.addEventListener('keyup', e=> { if(e.code==='Space') { spaceDown = false; mapCanvas.style.cursor = 'crosshair'; } });

mapCanvas.addEventListener('wheel', e=>{
  e.preventDefault();
  const mouseX = e.offsetX;
  const mouseY = e.offsetY;
  const wheel = e.deltaY < 0 ? 1.12 : 0.88;
  const worldX = (mouseX - offsetX) / scale;
  const worldY = (mouseY - offsetY) / scale;
  scale = Math.min(8, Math.max(0.2, scale * wheel));
  offsetX = mouseX - worldX * scale;
  offsetY = mouseY - worldY * scale;
  updateStatus();
  draw();
}, {passive:false});

/* ---------- Painting state ---------- */
let isPainting = false;
let isErasing = false;

mapCanvas.addEventListener('mousedown', e=>{
  // left = paint, middle = pan, right = erase
  if(e.button === 1 || (e.button === 0 && spaceDown)) {
    // start panning
    isPanning = true;
    panStart = { x: e.clientX, y: e.clientY, ox: offsetX, oy: offsetY };
    mapCanvas.style.cursor = 'grabbing';
    return;
  }

  if(e.button === 2) { // right-click erase
    e.preventDefault();
    isErasing = true;
    paintAtEvent(e, true);
    return;
  }

  // left click paint
  if(e.button === 0) {
    isPainting = true;
    paintAtEvent(e, false);
  }
});

window.addEventListener('mouseup', e=>{
  if(isPanning) { isPanning = false; mapCanvas.style.cursor = spaceDown ? 'grab' : 'crosshair'; }
  isPainting = false;
  isErasing = false;
});

mapCanvas.addEventListener('mousemove', e=>{
  if(isPanning) {
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    offsetX = panStart.ox + dx;
    offsetY = panStart.oy + dy;
    draw();
    updateStatus();
    return;
  }

  if(isPainting) paintAtEvent(e, false);
  if(isErasing) paintAtEvent(e, true);

  drawPreviewAt(e);
});

mapCanvas.addEventListener('contextmenu', e => { e.preventDefault(); }); // disable context menu

/* Support middle-mouse panning as well */
mapCanvas.addEventListener('mouseup', ()=> { isPanning=false; });
mapCanvas.addEventListener('mouseleave', ()=> { drawPreviewClear(); });

/* ---------- Tileset interaction ---------- */
tilesetCanvas.addEventListener('click', e=>{
  if(!tilesetImage) return;
  const tx = Math.floor(e.offsetX / tileSize);
  const ty = Math.floor(e.offsetY / tileSize);
  const across = Math.max(1, Math.floor(tilesetImage.width / tileSize));
  selectedTile = ty * across + tx;
  drawTileset();
  updateStatus();
});

/* redraw tileset with highlight */
function redrawTileset(){
  if(!tilesetImage) return;
  tilesetCanvas.width = tilesetImage.width;
  tilesetCanvas.height = tilesetImage.height;
  tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
  tilesetCtx.drawImage(tilesetImage, 0,0);
  drawTileset();
}

/* draw tileset highlight */
function drawTileset(){
  if(!tilesetImage) {
    tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
    tilesetInfo.textContent = 'No tileset loaded';
    return;
  }
  tilesetCtx.clearRect(0,0,tilesetCanvas.width,tilesetCanvas.height);
  tilesetCtx.drawImage(tilesetImage,0,0);
  const across = Math.max(1, Math.floor(tilesetImage.width / tileSize));
  tilesAcrossHeight.across = across;
  tilesAcrossHeight.rows = Math.ceil(tilesetImage.height / tileSize);
  tilesetInfo.textContent = `${tilesetImage.width}√ó${tilesetImage.height} ‚Äî ${across} across √ó ${tilesAcrossHeight.rows} rows`;

  if(selectedTile >= 0) {
    const sx = (selectedTile % across) * tileSize;
    const sy = Math.floor(selectedTile / across) * tileSize;
    tilesetCtx.lineWidth = 2;
    tilesetCtx.strokeStyle = 'yellow';
    tilesetCtx.strokeRect(sx+1, sy+1, tileSize-2, tileSize-2);
  }
}

/* handle file upload */
function handleTilesetUpload(e){
  const file = e.target.files[0];
  if(!file) return;
  const img = new Image();
  img.onload = () => {
    tilesetImage = img;
    tileSize = Math.max(4, parseInt(tileSizeInput.value,10) || 16);
    // If image width isn't divisible by tileSize, we still proceed
    tilesetCanvas.width = img.width;
    tilesetCanvas.height = img.height;
    drawTileset();
    draw();
  };
  img.src = URL.createObjectURL(file);
}

/* ---------- Map Data / Layers ---------- */
function createEmptyLayer(name){
  const arr = [];
  for(let y=0;y<mapHeight;y++){
    const row = [];
    for(let x=0;x<mapWidth;x++){
      row.push({ id: -1, x: x*tileSize, y: y*tileSize });
    }
    arr.push(row);
  }
  return { name: name||`Layer ${layers.length}`, visible:true, tiles: arr };
}

function createMap(w,h){
  mapWidth = w; mapHeight = h;
  // resize existing layers or create one if none
  if(layers.length === 0) {
    layers.push(createEmptyLayer('Ground'));
    activeLayer = 0;
  } else {
    for(const L of layers){
      // resize each layer to new size (top-left preserve)
      const newTiles = [];
      for(let y=0;y<mapHeight;y++){
        const row = [];
        for(let x=0;x<mapWidth;x++){
          if(L.tiles[y] && L.tiles[y][x]){
            row.push({ id: L.tiles[y][x].id, x: x*tileSize, y: y*tileSize });
          } else {
            row.push({ id: -1, x: x*tileSize, y: y*tileSize });
          }
        }
        newTiles.push(row);
      }
      L.tiles = newTiles;
    }
  }
  // (re)set canvas pixel size for preview layers
  resizeCanvases();
  refreshLayersUI();
  draw();
}

/* Layer management */
function addLayer(){
  const name = prompt('Layer name', `Layer ${layers.length}`);
  layers.splice(activeLayer+1, 0, createEmptyLayer(name));
  activeLayer = activeLayer+1;
  refreshLayersUI();
  draw();
}

function removeLayer(){
  if(layers.length === 0) return;
  if(!confirm('Remove active layer?')) return;
  layers.splice(activeLayer,1);
  activeLayer = Math.max(0, activeLayer-1);
  refreshLayersUI();
  draw();
}

function moveLayer(dir){
  const idx = activeLayer;
  const to = idx + dir;
  if(to < 0 || to >= layers.length) return;
  const tmp = layers[to];
  layers[to] = layers[idx];
  layers[idx] = tmp;
  activeLayer = to;
  refreshLayersUI();
  draw();
}

function refreshLayersUI(){
  layersList.innerHTML = '';
  for(let i=layers.length-1;i>=0;i--){ // show top first
    const L = layers[i];
    const item = document.createElement('div');
    item.className = 'layerItem' + (i===activeLayer ? ' active' : '');
    item.dataset.idx = i;
    item.innerHTML = `
      <input type="checkbox" ${L.visible ? 'checked' : ''} title="visible">
      <input type="text" value="${L.name}">
      <div style="margin-left:auto; display:flex; gap:6px; align-items:center;">
        <button class="btn smallBtn" data-action="eye">üëÅÔ∏è</button>
      </div>
    `;
    // checkbox toggles visibility
    const cb = item.querySelector('input[type=checkbox]');
    cb.addEventListener('change', ()=> {
      L.visible = cb.checked;
      draw();
    });

    // rename
    const nameInput = item.querySelector('input[type=text]');
    nameInput.addEventListener('change', ()=> {
      L.name = nameInput.value;
    });

    item.addEventListener('click', ()=> {
      activeLayer = i;
      refreshLayersUI();
      updateStatus();
      draw();
    });

    layersList.appendChild(item);
  }
  updateStatus();
}

/* ---------- Painting functions ---------- */
function paintAtEvent(e, erase){
  if(!layers[activeLayer]) return;
  const rect = mapCanvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const worldX = (sx - offsetX) / scale;
  const worldY = (sy - offsetY) / scale;
  const tx = Math.floor(worldX / tileSize);
  const ty = Math.floor(worldY / tileSize);

  let tileCoord = null;
  if(!erase && selectedTile >= 0 && tilesetImage) {
    const across = Math.max(1, Math.floor(tilesetImage.width / tileSize));
    tileCoord = { tx: selectedTile % across, ty: Math.floor(selectedTile / across) };
  }

  applyBrushAt(tx, ty, erase ? null : tileCoord);
  draw();
}

function applyBrushAt(tileX, tileY, tileCoord){
  if(!layers[activeLayer]) return;
  const brush = parseInt(document.getElementById('brushSize').value,10) || 1;
  const half = Math.floor((brush-1)/2);
  for(let by=0; by<brush; by++){
    for(let bx=0; bx<brush; bx++){
      const x = tileX + bx - half;
      const y = tileY + by - half;
      if(x < 0 || y < 0 || x >= mapWidth || y >= mapHeight) continue;
      if(tileCoord) {
        layers[activeLayer].tiles[y][x] = { tx: tileCoord.tx, ty: tileCoord.ty, x:x*tileSize, y:y*tileSize };
      } else {
        layers[activeLayer].tiles[y][x] = { tx:-1, ty:-1, x:x*tileSize, y:y*tileSize };
      }
    }
  }
}

/* ---------- Draw map ---------- */
function resizeCanvases(){
  // keep preview canvas same size as mapCanvas
  // set map canvas to container size
  const wrap = document.getElementById('canvasWrap');
  mapCanvas.width = wrap.clientWidth - 0;
  mapCanvas.height = wrap.clientHeight - 0;
  previewCanvas.width = mapCanvas.width;
  previewCanvas.height = mapCanvas.height;
}
window.addEventListener('resize', ()=> { resizeCanvases(); draw(); });
resizeCanvases();

function clearActiveLayer(){
  if(!layers[activeLayer]) return;
  for(let y=0;y<mapHeight;y++){
    for(let x=0;x<mapWidth;x++){
      layers[activeLayer].tiles[y][x] = { tx:-1, ty:-1, x:x*tileSize, y:y*tileSize };
    }
  }
  draw();
} 

function draw(){
  // clear canvas
  mapCtx.setTransform(1,0,0,1,0,0);
  mapCtx.clearRect(0,0,mapCanvas.width,mapCanvas.height);
  // apply transform
  mapCtx.setTransform(scale,0,0,scale,offsetX,offsetY);

  // draw background checker
  const checker = 8;
  mapCtx.fillStyle = '#080808';
  mapCtx.fillRect(0,0,mapWidth*tileSize, mapHeight*tileSize);

  // draw layers bottom->top
  for(let li=0; li<layers.length; li++){
    const L = layers[li];
    if(!L.visible) continue;
    // optionally skip layer preview? layerPreview toggles full visibility but we'll draw all if true
    for(let y=0;y<mapHeight;y++){
      for(let x=0;x<mapWidth;x++){
        const cell = L.tiles[y][x];
        if(cell.tx >= 0 && tilesetImage){
            const sx = cell.tx * tileSize;
            const sy = cell.ty * tileSize;
            try {
                mapCtx.drawImage(tilesetImage, sx, sy, tileSize, tileSize, cell.x, cell.y, tileSize, tileSize);
            } catch(err) {}
            }
      }
    }
  }

  // draw grid (in world coords)
  if(showGrid){
    mapCtx.strokeStyle = 'rgba(255,255,255,0.06)';
    mapCtx.lineWidth = 1/scale;
    for(let x=0;x<=mapWidth; x++){
      mapCtx.beginPath();
      mapCtx.moveTo(x*tileSize, 0);
      mapCtx.lineTo(x*tileSize, mapHeight*tileSize);
      mapCtx.stroke();
    }
    for(let y=0;y<=mapHeight; y++){
      mapCtx.beginPath();
      mapCtx.moveTo(0, y*tileSize);
      mapCtx.lineTo(mapWidth*tileSize, y*tileSize);
      mapCtx.stroke();
    }
  }

  // draw an outline of the map bounds
  mapCtx.lineWidth = 2/scale;
  mapCtx.strokeStyle = 'rgba(255,255,255,0.08)';
  mapCtx.strokeRect(0,0,mapWidth*tileSize,mapHeight*tileSize);

  // draw active layer highlight overlay (light tint)
  if(layers[activeLayer] && layerPreview) {
    mapCtx.fillStyle = 'rgba(50,160,255,0.03)';
    mapCtx.fillRect(0,0,mapWidth*tileSize, mapHeight*tileSize);
  }

  // reset transform for preview overlays
  mapCtx.setTransform(1,0,0,1,0,0);
  drawPreviewClear();
  updateStatus();
}

/* ---------- Preview (cursor following) ---------- */
function drawPreviewAt(e){
  previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  const rect = mapCanvas.getBoundingClientRect();
  const sx = e.clientX - rect.left;
  const sy = e.clientY - rect.top;
  const worldX = (sx - offsetX) / scale;
  const worldY = (sy - offsetY) / scale;
  const tx = Math.floor(worldX / tileSize);
  const ty = Math.floor(worldY / tileSize);

  const brush = parseInt(document.getElementById('brushSize').value,10) || 1;
  const half = Math.floor((brush-1)/2);

  if(tx < -10 || ty < -10 || tx > mapWidth+10 || ty > mapHeight+10) return;

  previewCtx.save();
  previewCtx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  previewCtx.translate(offsetX, offsetY);
  previewCtx.scale(scale, scale);

  // brush preview
  previewCtx.fillStyle = 'rgba(255,255,255,0.06)';
  previewCtx.strokeStyle = 'rgba(255,255,255,0.22)';
  previewCtx.lineWidth = 2/scale;

  for(let by=0; by<brush; by++){
    for(let bx=0; bx<brush; bx++){
      const x = tx + bx - half;
      const y = ty + by - half;
      if(x < 0 || y < 0 || x >= mapWidth || y >= mapHeight) continue;
      previewCtx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
      previewCtx.strokeRect(x*tileSize, y*tileSize, tileSize, tileSize);
    }
  }

  // tile preview (draw selected tile texture small opacity)
  if(selectedTile >= 0 && tilesetImage){
    const across = Math.max(1, Math.floor(tilesetImage.width / tileSize));
    const sxTile = selectedTile % across * tileSize;
    const syTile = Math.floor(selectedTile / across) * tileSize;
    previewCtx.globalAlpha = 0.9;
    previewCtx.drawImage(tilesetImage, sxTile, syTile, tileSize, tileSize,
                        tx*tileSize, ty*tileSize, tileSize, tileSize);
    previewCtx.globalAlpha = 1.0;
    }
  previewCtx.restore();
}

function drawPreviewClear(){
  // preview is drawn to separate canvas, but we clear it on draw()
  // don't clear here since draw() will call it; however we keep a safe clear
  // previewCtx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
}

/* ---------- Save / Load JSON ---------- */
function buildExportJSON(){
  const exportObj = {
    name: "MyMap",
    width: mapWidth,
    height: mapHeight,
    tile_size: tileSize,
    layers: layers.map(L => ({
      name: L.name,
      visible: !!L.visible,
      tiles: L.tiles.map(row => row.map(cell => ({ tx: cell.tx, ty: cell.ty })))
    }))
  };
  return exportObj;
}

function downloadJSON(){
  const obj = buildExportJSON();
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = (obj.name || 'map') + '.json';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function loadJSONFromFile(e){
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = function(evt){
    try {
      const j = JSON.parse(evt.target.result);
      loadFromJSONObj(j);
    } catch(err) {
      alert('Invalid JSON file');
      console.error(err);
    }
  };
  reader.readAsText(f);
}

function loadFromJSONObj(j){
  tileSize = j.tile_size || tileSize;
  tileSizeInput.value = tileSize;
  mapWidth = j.width; mapHeight = j.height;
  layers = [];
  for(const L of j.layers){
    if(L.tiles && Array.isArray(L.tiles) && L.tiles.length === mapHeight) {
      for(let y=0;y<mapHeight;y++){
        for(let x=0;x<mapWidth;x++){
          const c = L.tiles[y][x];
          if(!c) L.tiles[y][x] = { tx:-1, ty:-1, x:x*tileSize, y:y*tileSize };
          else L.tiles[y][x] = { tx:c.tx ?? -1, ty:c.ty ?? -1, x:x*tileSize, y:y*tileSize };
        }
      }
      layers.push({ name: L.name || 'Layer', visible: !!L.visible, tiles: L.tiles });
    } else {
      layers.push(createEmptyLayer(L.name || 'Layer'));
    }
  }
  activeLayer = Math.max(0, layers.length-1);
  document.getElementById('mapWidth').value = mapWidth;
  document.getElementById('mapHeight').value = mapHeight;
  resizeCanvases();
  refreshLayersUI();
  draw();
}

/* ---------- Utilities ---------- */
function updateStatus(){
  statusEl.textContent = `Selected tile: ${selectedTile} | Layer: ${layers[activeLayer] ? layers[activeLayer].name : '-'} (${activeLayer}) | Scale: ${Math.round(scale*100)}%`;
}

/* ---------- Init defaults ---------- */
(function init(){
  // create default map and layer
  createMap(mapWidth, mapHeight);
  if(!layers.length) layers.push(createEmptyLayer('Ground'));
  activeLayer = 0;
  refreshLayersUI();
  draw();

  // make canvases resize with container
  const wrap = document.getElementById('canvasWrap');
  const observer = new ResizeObserver(() => { resizeCanvases(); draw(); });
  observer.observe(wrap);
})();

</script>
</body>
</html>
